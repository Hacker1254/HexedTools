// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#nullable enable

#if ENCODER && OPCODE_INFO
namespace Iced.Intel.EncoderInternal {
	static class OpCodeOperandKinds {
#if HAS_SPAN
		public static System.ReadOnlySpan<byte> LegacyOpKinds => new byte[76] {
#else
		public static readonly byte[] LegacyOpKinds = new byte[76] {
#endif
			(byte)OpCodeOperandKind.None,
			(byte)OpCodeOperandKind.farbr2_2,
			(byte)OpCodeOperandKind.farbr4_2,
			(byte)OpCodeOperandKind.mem_offs,
			(byte)OpCodeOperandKind.mem,
			(byte)OpCodeOperandKind.mem_mpx,
			(byte)OpCodeOperandKind.mem_mib,
			(byte)OpCodeOperandKind.r8_or_mem,
			(byte)OpCodeOperandKind.r16_or_mem,
			(byte)OpCodeOperandKind.r32_or_mem,
			(byte)OpCodeOperandKind.r32_or_mem_mpx,
			(byte)OpCodeOperandKind.r64_or_mem,
			(byte)OpCodeOperandKind.r64_or_mem_mpx,
			(byte)OpCodeOperandKind.mm_or_mem,
			(byte)OpCodeOperandKind.xmm_or_mem,
			(byte)OpCodeOperandKind.bnd_or_mem_mpx,
			(byte)OpCodeOperandKind.r8_reg,
			(byte)OpCodeOperandKind.r8_opcode,
			(byte)OpCodeOperandKind.r16_reg,
			(byte)OpCodeOperandKind.r16_reg_mem,
			(byte)OpCodeOperandKind.r16_rm,
			(byte)OpCodeOperandKind.r16_opcode,
			(byte)OpCodeOperandKind.r32_reg,
			(byte)OpCodeOperandKind.r32_reg_mem,
			(byte)OpCodeOperandKind.r32_rm,
			(byte)OpCodeOperandKind.r32_opcode,
			(byte)OpCodeOperandKind.r64_reg,
			(byte)OpCodeOperandKind.r64_reg_mem,
			(byte)OpCodeOperandKind.r64_rm,
			(byte)OpCodeOperandKind.r64_opcode,
			(byte)OpCodeOperandKind.seg_reg,
			(byte)OpCodeOperandKind.mm_reg,
			(byte)OpCodeOperandKind.mm_rm,
			(byte)OpCodeOperandKind.xmm_reg,
			(byte)OpCodeOperandKind.xmm_rm,
			(byte)OpCodeOperandKind.cr_reg,
			(byte)OpCodeOperandKind.dr_reg,
			(byte)OpCodeOperandKind.tr_reg,
			(byte)OpCodeOperandKind.bnd_reg,
			(byte)OpCodeOperandKind.es,
			(byte)OpCodeOperandKind.cs,
			(byte)OpCodeOperandKind.ss,
			(byte)OpCodeOperandKind.ds,
			(byte)OpCodeOperandKind.fs,
			(byte)OpCodeOperandKind.gs,
			(byte)OpCodeOperandKind.al,
			(byte)OpCodeOperandKind.cl,
			(byte)OpCodeOperandKind.ax,
			(byte)OpCodeOperandKind.dx,
			(byte)OpCodeOperandKind.eax,
			(byte)OpCodeOperandKind.rax,
			(byte)OpCodeOperandKind.st0,
			(byte)OpCodeOperandKind.sti_opcode,
			(byte)OpCodeOperandKind.imm8,
			(byte)OpCodeOperandKind.imm8_const_1,
			(byte)OpCodeOperandKind.imm8sex16,
			(byte)OpCodeOperandKind.imm8sex32,
			(byte)OpCodeOperandKind.imm8sex64,
			(byte)OpCodeOperandKind.imm16,
			(byte)OpCodeOperandKind.imm32,
			(byte)OpCodeOperandKind.imm32sex64,
			(byte)OpCodeOperandKind.imm64,
			(byte)OpCodeOperandKind.seg_rSI,
			(byte)OpCodeOperandKind.es_rDI,
			(byte)OpCodeOperandKind.seg_rDI,
			(byte)OpCodeOperandKind.seg_rBX_al,
			(byte)OpCodeOperandKind.br16_1,
			(byte)OpCodeOperandKind.br32_1,
			(byte)OpCodeOperandKind.br64_1,
			(byte)OpCodeOperandKind.br16_2,
			(byte)OpCodeOperandKind.br32_4,
			(byte)OpCodeOperandKind.br64_4,
			(byte)OpCodeOperandKind.xbegin_2,
			(byte)OpCodeOperandKind.xbegin_4,
			(byte)OpCodeOperandKind.brdisp_2,
			(byte)OpCodeOperandKind.brdisp_4,
		};
#if !NO_VEX
#if HAS_SPAN
		public static System.ReadOnlySpan<byte> VexOpKinds => new byte[39] {
#else
		public static readonly byte[] VexOpKinds = new byte[39] {
#endif
			(byte)OpCodeOperandKind.None,
			(byte)OpCodeOperandKind.mem,
			(byte)OpCodeOperandKind.mem_vsib32x,
			(byte)OpCodeOperandKind.mem_vsib64x,
			(byte)OpCodeOperandKind.mem_vsib32y,
			(byte)OpCodeOperandKind.mem_vsib64y,
			(byte)OpCodeOperandKind.r32_or_mem,
			(byte)OpCodeOperandKind.r64_or_mem,
			(byte)OpCodeOperandKind.xmm_or_mem,
			(byte)OpCodeOperandKind.ymm_or_mem,
			(byte)OpCodeOperandKind.k_or_mem,
			(byte)OpCodeOperandKind.r32_reg,
			(byte)OpCodeOperandKind.r32_rm,
			(byte)OpCodeOperandKind.r32_vvvv,
			(byte)OpCodeOperandKind.r64_reg,
			(byte)OpCodeOperandKind.r64_rm,
			(byte)OpCodeOperandKind.r64_vvvv,
			(byte)OpCodeOperandKind.k_reg,
			(byte)OpCodeOperandKind.k_rm,
			(byte)OpCodeOperandKind.k_vvvv,
			(byte)OpCodeOperandKind.xmm_reg,
			(byte)OpCodeOperandKind.xmm_rm,
			(byte)OpCodeOperandKind.xmm_vvvv,
			(byte)OpCodeOperandKind.xmm_is4,
			(byte)OpCodeOperandKind.xmm_is5,
			(byte)OpCodeOperandKind.ymm_reg,
			(byte)OpCodeOperandKind.ymm_rm,
			(byte)OpCodeOperandKind.ymm_vvvv,
			(byte)OpCodeOperandKind.ymm_is4,
			(byte)OpCodeOperandKind.ymm_is5,
			(byte)OpCodeOperandKind.imm4_m2z,
			(byte)OpCodeOperandKind.imm8,
			(byte)OpCodeOperandKind.seg_rDI,
			(byte)OpCodeOperandKind.br64_1,
			(byte)OpCodeOperandKind.br64_4,
			(byte)OpCodeOperandKind.sibmem,
			(byte)OpCodeOperandKind.tmm_reg,
			(byte)OpCodeOperandKind.tmm_rm,
			(byte)OpCodeOperandKind.tmm_vvvv,
		};
#endif
#if !NO_XOP
#if HAS_SPAN
		public static System.ReadOnlySpan<byte> XopOpKinds => new byte[19] {
#else
		public static readonly byte[] XopOpKinds = new byte[19] {
#endif
			(byte)OpCodeOperandKind.None,
			(byte)OpCodeOperandKind.r32_or_mem,
			(byte)OpCodeOperandKind.r64_or_mem,
			(byte)OpCodeOperandKind.xmm_or_mem,
			(byte)OpCodeOperandKind.ymm_or_mem,
			(byte)OpCodeOperandKind.r32_reg,
			(byte)OpCodeOperandKind.r32_rm,
			(byte)OpCodeOperandKind.r32_vvvv,
			(byte)OpCodeOperandKind.r64_reg,
			(byte)OpCodeOperandKind.r64_rm,
			(byte)OpCodeOperandKind.r64_vvvv,
			(byte)OpCodeOperandKind.xmm_reg,
			(byte)OpCodeOperandKind.xmm_vvvv,
			(byte)OpCodeOperandKind.xmm_is4,
			(byte)OpCodeOperandKind.ymm_reg,
			(byte)OpCodeOperandKind.ymm_vvvv,
			(byte)OpCodeOperandKind.ymm_is4,
			(byte)OpCodeOperandKind.imm8,
			(byte)OpCodeOperandKind.imm32,
		};
#endif
#if !NO_EVEX
#if HAS_SPAN
		public static System.ReadOnlySpan<byte> EvexOpKinds => new byte[32] {
#else
		public static readonly byte[] EvexOpKinds = new byte[32] {
#endif
			(byte)OpCodeOperandKind.None,
			(byte)OpCodeOperandKind.mem,
			(byte)OpCodeOperandKind.mem_vsib32x,
			(byte)OpCodeOperandKind.mem_vsib64x,
			(byte)OpCodeOperandKind.mem_vsib32y,
			(byte)OpCodeOperandKind.mem_vsib64y,
			(byte)OpCodeOperandKind.mem_vsib32z,
			(byte)OpCodeOperandKind.mem_vsib64z,
			(byte)OpCodeOperandKind.r32_or_mem,
			(byte)OpCodeOperandKind.r64_or_mem,
			(byte)OpCodeOperandKind.xmm_or_mem,
			(byte)OpCodeOperandKind.ymm_or_mem,
			(byte)OpCodeOperandKind.zmm_or_mem,
			(byte)OpCodeOperandKind.r32_reg,
			(byte)OpCodeOperandKind.r32_rm,
			(byte)OpCodeOperandKind.r64_reg,
			(byte)OpCodeOperandKind.r64_rm,
			(byte)OpCodeOperandKind.k_reg,
			(byte)OpCodeOperandKind.kp1_reg,
			(byte)OpCodeOperandKind.k_rm,
			(byte)OpCodeOperandKind.xmm_reg,
			(byte)OpCodeOperandKind.xmm_rm,
			(byte)OpCodeOperandKind.xmm_vvvv,
			(byte)OpCodeOperandKind.xmmp3_vvvv,
			(byte)OpCodeOperandKind.ymm_reg,
			(byte)OpCodeOperandKind.ymm_rm,
			(byte)OpCodeOperandKind.ymm_vvvv,
			(byte)OpCodeOperandKind.zmm_reg,
			(byte)OpCodeOperandKind.zmm_rm,
			(byte)OpCodeOperandKind.zmm_vvvv,
			(byte)OpCodeOperandKind.zmmp3_vvvv,
			(byte)OpCodeOperandKind.imm8,
		};
#endif
#if MVEX
#if HAS_SPAN
		public static System.ReadOnlySpan<byte> MvexOpKinds => new byte[9] {
#else
		public static readonly byte[] MvexOpKinds = new byte[9] {
#endif
			(byte)OpCodeOperandKind.None,
			(byte)OpCodeOperandKind.mem,
			(byte)OpCodeOperandKind.mem_vsib32z,
			(byte)OpCodeOperandKind.zmm_or_mem,
			(byte)OpCodeOperandKind.k_reg,
			(byte)OpCodeOperandKind.k_vvvv,
			(byte)OpCodeOperandKind.zmm_reg,
			(byte)OpCodeOperandKind.zmm_vvvv,
			(byte)OpCodeOperandKind.imm8,
		};
#endif
	}
}
#endif
